#+title: init.org
#+property: header-args:emacs-lisp :tangle ~/.emacs.d/init.el

* Preface | 前言

** How to Install | 如何安裝

Press =C-c C-v t= (~org-babel-tangle~) while reading this file inside Emacs, to generate the actual
configuration file, ~init.el~. Relaunch Emacs to make the configuration take effect.

Alternatively, you can use this command in Shell to generate the configuration file: (replace "/path/to/init.org" with the actual path of this file)

#+begin_src shell
  emacs --batch --eval "(require 'org)" --eval '(org-babel-tangle-file "/path/to/init.org")'
#+end_src

** Naming Conventions | 命名慣例

This section is inspired by [[https://docs.doomemacs.org/latest/#/developers/conventions/emacs-lisp/naming-conventions][Doom Emacs naming conventions]].

Symbol names starts with ~NAMESPACE~, where ~NAMESPACE~ is usually ~zy~.

- ~NAMESPACE/NAME~ :: A public command designed to be used interactively, via =M-x= or a keybinding.
- ~NAMESPACE$NAME~ :: A customizable variable.
- ~NAMESPACE-NAME~ :: A non-interactive function, or a non-customizable variable.
- ~NAMESPACE--NAME~ :: A protected function or variable.
- ~abc!~ or ~NAMESPACE-abc!~ :: A macro.

The optional ~-~ added before symbol ~NAME~ signifies a protected function/variable that should only be used internally.

* Startup | 啟動

** Early Init

See [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Early-Init-File.html][The Early Init File]].

#+begin_src emacs-lisp :tangle ~/.emacs.d/early-init.el
  ;; -*- lexical-binding: t; -*-
  (setq frame-inhibit-implied-resize t
        inhibit-startup-message t
        native-comp-async-report-warnings-errors nil
        package-enable-at-startup nil)
#+end_src

** Startup Timer

#+begin_src emacs-lisp
  (defun display-startup-echo-area-message ()
    (message
     (format "ZyEmacs ready in %.2f seconds."
             (float-time
              (time-subtract after-init-time before-init-time)))))
#+end_src

** Adjust GC

Prohibit GC at startup, and adjust the threshold thereafter.

#+begin_src emacs-lisp
  (setq gc-cons-threshold most-positive-fixnum
        gc-cons-percentage 0.5)
  (add-hook 'emacs-startup-hook
            (lambda ()
              (setq gc-cons-threshold (* 32 1024 1024)
                    gc-cons-percentage 0.1)))
#+end_src

** Load Libraries

#+begin_src emacs-lisp
  (require 'cl-lib)
  (require 'cl-extra)
#+end_src

** My Macros

*** Logical Macros

#+begin_src emacs-lisp
  (defmacro nor! (&rest conditions)
    `(not (or ,@conditions)))
  (defmacro nand! (&rest conditions)
    `(not (and ,@conditions)))
#+end_src

*** Hook Macros

#+begin_src emacs-lisp
  (defmacro add-hooks! (hook-list function &optional depth local)
    "Add FUNCTION to each hook in HOOK-LIST."
    (let ((result '(progn))
          (hook-list (cadr hook-list)))
      (dolist (hook hook-list)
        (add-to-list
         'result
         `(add-hook ',hook ,function ,depth ,local)
         'append))
      result))

  (defmacro add-hook-lambda! (hook &rest body)
    "Add a lambda function of BODY to the value of HOOK."
    (declare (indent 1) (debug (form def-body)))
    `(add-hook ,hook (lambda () ,@body)))

  (defmacro add-hooks-lambda! (hook-list &rest body)
    "Add a lambda function of BODY to each hook in HOOK-LIST."
    (declare (indent 1) (debug (form def-body)))
    (let ((result '(progn))
          (hook-list (cadr hook-list)))
      (dolist (hook hook-list)
        (add-to-list
         'result
         `(add-hook ',hook (lambda () ,@body))
         'append))
      result))
#+end_src

Examples of these macros:

#+begin_src emacs-lisp :tangle no
  (add-hooks! '(some-hook another-hook) #'some-function)
  (add-hook-lambda! 'some-hook
    (do-something)
    (do-something-else))
  (add-hooks-lambda! '(some-hook another-hook)
    (do-something)
    (do-something-else))
#+end_src

*** Configuration Groupers

#+begin_src emacs-lisp
  (defmacro run-with-idle-timer! (secs &rest body)
    "Run BODY after being idle for SECS seconds."
    (declare (indent 1) (debug (form def-body)))
    `(run-with-idle-timer ,secs nil (lambda () ,@body)))
#+end_src

** Constants

#+begin_src emacs-lisp
  (defconst zy-*windows* (eq system-type 'windows-nt)
    "If Emacs is run on Windows.")
  (defconst zy-*linux* (or (eq system-type 'gnu/linux)
                            (eq system-type 'linux))
    "If Emacs is run on Linux.

  Note that WSL is also Linux.")
  (defconst zy-*wsl* (equal
                       0
                       (shell-command
                        "grep -q microsoft /proc/version"))
    "If Emacs is run on WSL.")
#+end_src

** Load ~custom.el~

#+begin_src emacs-lisp
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  (when (file-exists-p custom-file)
    (load custom-file))
#+end_src

** Lisp Path

#+begin_src emacs-lisp
  (let ((lisp-directories
	 '("lisp" "site-lisp")))
    (dolist (dir lisp-directories)
      (setq dir (expand-file-name dir user-emacs-directory))
      (when (file-directory-p dir)
	(let ((default-directory dir))
	  (normal-top-level-add-subdirs-to-load-path)))))
#+end_src

** User Paths

Zybox is the collection of my personal files.

#+begin_src emacs-lisp
  (defcustom zy$use-zybox-p t
    "Should ZyEmacs use the workflow designed around Zybox.

  Zybox is private directory of Zyxir, and ZyEmacs has a set of
  utilities to work with Zybox. If you are not Zyxir, the workflow
  is meaningless.

  If no valid path of Zybox is detected or set by the user, this
  value will be automatically set to nil."
    :type 'boolean)

  (defcustom zy$zybox-path nil
    "The path of Zybox, the collection of all my files.

  If it is not auto-detected, customize it to the actual path."
    :type 'directory)

  (defun zy--find-zybox ()
    "Try to auto-detect the location of Zybox."
    (let* ((zybox-possible-locs-windows
            '("C:\\Zybox"
              "C:\\Users\\zyxir\\Zybox"
              "C:\\Users\\zyxir\\Documents\\Zybox"))
           (zybox-possible-locs-linux
            '("~/Zybox"
              "~/Documents/Zybox"
              "/mnt/c/Zybox"
              "/mnt/c/Users/zyxir/Zybox"
              "/mnt/c/Users/Documents/Zybox"))
           (path-found
            (cl-some
             (lambda (path) (when (file-directory-p path) path))
             (cond
              (zy-*windows* zybox-possible-locs-windows)
              (zy-*linux* zybox-possible-locs-linux)))))
      (if path-found
          (lwarn 'zyemacs :warning
                 "Zybox is auto-detected at %s." path-found)
        (lwarn 'zyemacs :warning "Could not auto-detect Zybox."))
      path-found))

  (when (and zy$use-zybox-p
             (not zy$zybox-path))
    (setq zy$zybox-path (zy--find-zybox))
    (if zy$zybox-path
        (customize-save-variable 'zy$zybox-path zy$zybox-path)
      (customize-save-variable 'zy$use-zybox-p nil)))
#+end_src

* Utilities | 組件

** Straight

Install package with straight.

#+begin_src emacs-lisp
  (unless (featurep 'straight)
    ;; Bootstrap straight.el
    (defvar bootstrap-version)
    (let ((bootstrap-file
	   (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
	  (bootstrap-version 5))
      (unless (file-exists-p bootstrap-file)
	(with-current-buffer
	    (url-retrieve-synchronously
	     "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
	     'silent 'inhibit-cookies)
	  (goto-char (point-max))
	  (eval-print-last-sexp)))
      (load bootstrap-file nil 'nomessage)))
  (setq straight-vc-git-default-clone-depth 1)
#+end_src

** Which-Key

#+begin_src emacs-lisp
  (straight-use-package 'which-key)
  (which-key-mode +1)
#+end_src

** General.el

Manage keybinding with general.el, and rebind some default keys. Additionally, define ~M-m~ as my leader-key.

#+begin_src emacs-lisp
  (straight-use-package 'general)
  (define-prefix-command 'zy-leader-map)

  (defcustom zy$leader-key "M-m"
    "The leader key of ZyEmacs."
    :type 'key)

  (general-define-key zy$leader-key 'zy-leader-map
                      "M-z" 'back-to-indentation)
#+end_src

** ZyEmacs Keymaps

Define several leader keymaps.

#+begin_src emacs-lisp
  (define-prefix-command 'zy-leader-manage-map)
  (general-define-key
   :keymaps 'zy-leader-map
   "m" 'zy-leader-manage-map
   "M-m" 'zy-leader-manage-map)
#+end_src

** Vertico and Minibuffer

#+begin_src emacs-lisp
  ;; Setup Vertico.
  (straight-use-package 'vertico)
  (vertico-mode +1)

  ;; Setup Orderless.
  (straight-use-package 'orderless)
  (setq completion-styles '(orderless partial-completion)
        completion-category-defaults nil
        completion-category-overrides '((file (styles partial-completion))))

  ;; Setup Savehist.
  (straight-use-package 'savehist)
  (savehist-mode +1)

  ;; Setup Marginalia.
  (straight-use-package 'marginalia)
  (marginalia-mode +1)

  ;; Other minibuffer settings.
  (setq minibuffer-prompt-properties
        '(read-only t cursor-intangible t face minibuffer-prompt)
        enable-recursive-minibuffers t)
  (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)
#+end_src

** Consult

Register utilities have not been configured.

#+begin_src emacs-lisp
  (straight-use-package 'consult)
  (setq completion-in-region-function
        #'consult-completion-in-region)
  (advice-add #'completing-read-multiple
              :override #'consult-completing-read-multiple)

  (general-define-key
   "M-y" 'consult-yank-pop
   "<help> a" 'consult-apropos)

  (general-define-key
   :keymaps 'mode-specific-map
   "h" 'consult-history
   "m" 'consult-mode-command
   "k" 'consult-kmacro)

  (general-define-key
   :keymaps 'ctl-x-map
   "M-:" 'consult-complex-command
   "b" 'consult-buffer
   "4 b" 'consult-buffer-other-window
   "5 b" 'consult-buffer-other-frame
   "r b" 'consult-bookmark
   "p b" 'consult-project-buffer)

  (general-define-key
   :keymaps 'goto-map
   "e" 'consult-compile-error
   "f" 'consult-flymake
   "g" 'consult-goto-line
   "M-g" 'consult-goto-line
   "o" 'consult-outline
   "m" 'consult-mark
   "k" 'consult-global-mark
   "i" 'consult-imenu
   "I" 'consult-imenu-multi)

  (general-define-key
   :keymaps 'search-map
   "d" 'consult-find
   "D" 'consult-locate
   "g" 'consult-grep
   "G" 'consult-git-grep
   "r" 'consult-ripgrep
   "l" 'consult-line
   "L" 'consult-line-multi
   "m" 'consult-multi-occur
   "k" 'consult-keep-lines
   "u" 'consult-focus-lines)

  (general-define-key
   :keymaps 'isearch-mode-map
   "M-e" 'consult-isearch-history
   "M-s e" 'consult-isearch-history
   "M-s l" 'consult-line
   "M-s L" 'consult-line-multi)

  (general-define-key
   :keymaps 'minibuffer-local-map
   "M-s" 'consult-history
   "M-r" 'consult-history)
#+end_src

** Emacs Server

#+begin_src emacs-lisp
  (run-with-idle-timer! 1
    (require 'server)
    (unless (server-running-p)
      (server-start)))
#+end_src

* General | 一般性設置

** Native Setqs

#+begin_src emacs-lisp
  (setq
   auto-save-default nil
   disabled-command-function nil
   fill-column 80
   frame-title-format (if zy-*windows*
                          '("" "windows-emacs" " [%b]")
                        '("" "emacs" " [%b]"))
   inhibit-compacting-font-caches t
   make-backup-files nil
   system-time-locale "C"
   word-wrap-by-category t)
#+end_src

** Native Modes

#+begin_src emacs-lisp
  (add-hook-lambda! 'after-init-hook
    (delete-selection-mode +1)
    (global-display-line-numbers-mode +1)
    (global-subword-mode +1)
    (recentf-mode +1)
    (save-place-mode +1)
    (load "kinsoku" 'noerror 'nomessage))

  (add-hooks-lambda! '(prog-mode-hook text-mode-hook)
    (setq-local show-trailing-whitespace t)
    (hl-line-mode +1))
#+end_src

** Super Save

#+begin_src emacs-lisp
  (straight-use-package 'super-save)
  (setq super-save-auto-save-when-idle t)
  (super-save-mode +1)
#+end_src

** Magit

#+begin_src emacs-lisp
  (straight-use-package 'magit)
  (general-define-key
   :keymaps 'ctl-x-map
   "g" 'magit-status
   "M-g" 'magit-dispatch)
#+end_src

** Valign

#+begin_src emacs-lisp
  (straight-use-package 'valign)
  (add-hooks! '(org-mode-hook
                markdown-mode-hook)
              #'valign-mode)
#+end_src

** Restart-Emacs

Restart Emacs within Emacs, or open a new instance of Emacs. This is extremely useful for configuring Emacs.

[2022-03-20 Sun] ~restart-emacs-start-new-emacs~ does not receive prefix arguments, so switch it to a working fork.

#+begin_src emacs-lisp
  (straight-use-package '(restart-emacs
                          :type git :host github
                          :repo "wyuenho/restart-emacs"
                          :branch "patch-1"))

  (defun zy/tangle-config-and-start-new-emacs ()
    "Tangle the config file and start a new instance of Emacs.

  This is a handy function for daily configuration: it apply
  `org-babel-tangle-file' on init.org to generate the modified
  configuration, and start a new instance of Emacs to test the new
  configuration, with --debug-init enabled."
    (interactive)
    (require 'ob)
    (org-babel-tangle-file
     (expand-file-name "init.org" user-emacs-directory))
    (restart-emacs-start-new-emacs '("--debug-init")))

  (general-define-key
   :keymaps 'zy-leader-manage-map
   "R" 'restart-emacs
   "N" 'restart-emacs-start-new-emacs
   "T" 'zy/tangle-config-and-start-new-emacs)
#+end_src

* UI | 用戶界面

** Toggle UI Elements

#+begin_src emacs-lisp
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (column-number-mode +1)
#+end_src

** Theme

*** Load Default Theme

#+begin_src emacs-lisp
  (defun zy-theme-func-default ()
    "Default function to setup theme."
    (if (display-graphic-p)
        (progn
          (straight-use-package 'spacemacs-theme)
          (require 'spacemacs-common)
          (load-theme 'spacemacs-light t))
      (load-theme 'wombat t)))

  (defcustom zy$theme-func #'zy-theme-func-default
    "Function to setup theme."
    :type 'function)

  (funcall zy$theme-func)

  (defcustom zy$use-solaire-p t
    "Should ZyEmacs install and enable 'solaire-mode'."
    :type 'boolean)

  (when zy$use-solaire-p
    (straight-use-package 'solaire-mode)
    (solaire-global-mode +1))
#+end_src

*** Theme Hooks

#+begin_src emacs-lisp
  (defvar after-enable-theme-hook nil
    "Hook run after a theme is enabled via `enable-theme'.

  `enable-theme' always enables the theme 'user' as well, and that
  won't trigger this hook.

  Note that `load-theme' also runs `enable-theme'.")

  (defun run-after-enable-theme-hook (theme)
    "Run `after-enable-theme-hook'."
    (unless (equal theme 'user)
      (run-hooks 'after-enable-theme-hook)))

  (advice-add #'enable-theme :after #'run-after-enable-theme-hook)
#+end_src

** Font

Font configuration is always a pain for Emacsers who use Chinese. To help more people in need, comments in this section would be bilingual. | 字體配置一直是中文 Emacs 用戶的痛。爲了幫到更多有需要的人，这一部分配置的所有評論將以雙語寫成。

*** The System | 字體系統概述

In ZyEmacs, a fontlist is a table like below, that defines ~main-font~ as the default font for displaying text, and assigns fonts for each charset. | 在 ZyEmacs 中，​*字體列表（fontlist）*​是滿足如下格式的列表，它定義了 ~main-font~ 作爲默認顯示字體，並且爲各個字符集指定了適用於它們的字體。

#+begin_src emacs-lisp :tangle no
  '((main-font [size [weight]])
    (charset1 font [weight [append]])
    (charset2 font [weight [append]])
    ((charset3 charset4 charset5) font [weight [append]]))
#+end_src

The core of the font system is the function ~zy-fontlist-apply~. It converts a fontlist to a font (the ~main-font~) and a fontset (from the fonts assigned to each charset), and apply them to a given face. | 這一字體系統的核心是 ~zy-fontlist-apply~ 函數。它將一個 fontlist 轉換爲一個字體（即 ~main-font~​）和一個字體集（來自被指派給各個字符集的字體；字體集 fontset 是Emacs 原本就有的概念），並將它們分配給一個給定的 face。

The font system provides a more convenient interface for multilingual font setup, compared to the default fontset interface. | 相較于默認的字體系統，這一字體系統提供了一個更便利的字體設置接口，能夠更方便地爲多個語言配置字體。

*** ~zy-fontlist-apply~

Apply a fontlist to a given face.

#+begin_src emacs-lisp
  (defvar zy--fs-counter 0
    "How many fontset have been created by ZyEmacs.")

  (defun zy-fontlist-apply (fontlist &optional face frame)
    "Apply FONTLIST to FACE on FRAME.

  If FACE is nil or omitted, apply to the default face.

  If FRAME is nil, set the attributes for all existing frames, as
  well as the default for new frames.  If FRAME is t, change the
  default for new frames only."
    (let* ((face (if face face 'default))
           (main (car fontlist))
           (main-spec-expr '(font-spec))
           main-spec
           fontset
           (fontset-is-new nil)
           (cflist (cdr fontlist)))
      ;; Set main font.
      (when (car main)
        (setq main-spec-expr
              (append main-spec-expr `(:family ,(car main)))))
      (when (cadr main)
        (setq main-spec-expr
              (append main-spec-expr `(:size ,(cadr main)))))
      (when (caddr main)
        (setq main-spec-expr
              (append main-spec-expr `(:weight ,(caddr main)))))
      (setq main-spec (eval main-spec-expr))
      (when (find-font main-spec)
        (set-face-attribute face frame :font main-spec))
      (unless (cadr main)
        (set-face-attribute face frame :height 'unspecified))
      ;; Get the :fontset attribution of FACE. If it is 'unspecified',
      ;; create a new fontset.
      (setq fontset (face-attribute face :fontset frame))
      (when (equal fontset 'unspecified)
        (setq fontset
              (new-fontset
               (format "-*-*-*-*-*--*-*-*-*-*-*-fontset-zyfs%d"
                       zy--fs-counter)
               nil)
              zy--fs-counter (+ zy--fs-counter 1)
              fontset-is-new t))
      ;; Loop 'cflist' to set font for each charset.
      (dolist (cfpair cflist)
        (let* ((charset-or-charsets (car cfpair))
               (append (cadddr cfpair));
               (spec-expr '(font-spec))
               spec)
          (when (cadr cfpair)
            (setq spec-expr
                  (append spec-expr `(:family ,(cadr cfpair)))))
          (when (caddr cfpair)
            (setq spec-expr
                  (append spec-expr `(:weight ,(caddr cfpair)))))
          (setq spec (eval spec-expr))
          (when (find-font spec)
            (if (listp charset-or-charsets)
                (dolist (charset charset-or-charsets)
                  (set-fontset-font fontset charset spec frame
                                    append))
              (set-fontset-font fontset charset-or-charsets spec
                                frame append)))))
      ;; If 'fontset' is newly created, assign it to FACE.
      (when fontset-is-new
        (set-face-attribute face frame :fontset fontset))))
#+end_src

*** ~zy-copy-fontlist-without-size~

Get a copy of the fontlist without the size information.

#+begin_src emacs-lisp
  (defun zy-copy-fontlist-without-size (fontlist)
    "Return a copy of FONTLIST, where size info is omitted."
    (let* ((new-fontlist (copy-tree fontlist))
           (main (car new-fontlist)))
      (when (cdr main)
        (setcar (cdr main) nil))
      new-fontlist))
#+end_src

*** ~zy-fontlist-adjust-size~

Adjust the size of a fontlist.

#+begin_src emacs-lisp
  (defun zy-fontlist-adjust-size (fontlist adjust)
    "Adjust the font size by ADJUST for FONTLIST."
    (let* ((main (car fontlist))
           (size (cadr main)))
      (when size
        (setcar (cdr main) (+ size adjust)))))
#+end_src

*** Macros | 宏

#+begin_src emacs-lisp
  (defmacro zy-fontlist-apply! (fontlist &rest faces)
    "Apply FONTLIST to each face in FACES."
    (let ((body '(progn)))
      (dolist (face faces)
        (add-to-list
         'body
         `(zy-fontlist-apply ,fontlist ,face nil)
         'append))
      body))

  (defmacro zy-pick-font! (&rest fonts)
    "Get the first available font in FONTS."
    `(let ((--fonts-tail-- ',fonts)
           font
           (result nil))
       (while --fonts-tail--
         (setq font (car --fonts-tail--))
         (if (x-list-fonts font)
             (setq result font
                   --fonts-tail-- nil)
           (setq --fonts-tail--
                 (cdr --fonts-tail--))))
       result))

  (defmacro zy-pick-main-font! (&rest mains)
    "Get the first available main font in MAINS.

  Each element of MAINS is like (font size weight)."
    `(let ((--mains-tail-- ',mains)
           main
           (result nil))
       (while --mains-tail--
         (setq main (car --mains-tail--))
         (let ((main-spec-expr '(font-spec))
               main-sepc)
           (when (car main)
             (setq main-spec-expr
                   (append main-spec-expr
                           `(:family ,(car main)))))
           (when (cadr main)
             (setq main-spec-expr
                   (append main-spec-expr
                           `(:size ,(cadr main)))))
           (when (caddr main)
             (setq main-spec-expr
                   (append main-spec-expr
                           `(:weight ,(caddr main)))))
           (setq main-spec (eval main-spec-expr))
           (if (find-font main-spec)
               (setq result main
                     --mains-tail-- nil)
             (setq --mains-tail--
                   (cdr --mains-tail--)))))
       result))
#+end_src

*** Create and Apply Fontlists | 創建和應用字體列表

You can customise these variables to modify fonts.

- ~zy$fontlist-default~
- ~zy$fontlist-varpitch~
- ~zy$fontlist-title~
- ~zy$font-size-adjust~

#+begin_src emacs-lisp
  (when (display-graphic-p)
    (add-hook-lambda! 'after-init-hook

      (defconst zy-fontlist-default-preset
        `(,(zy-pick-main-font! ("Sarasa Mono Slab TC" 16)
                               ("Iosevka Term Slab" 16)
                               ("Consolas" 16)
                               ("monospace" 16))
          ((han cjk-misc bopomofo kana)
           ,(zy-pick-font! "GenYoGothic TW"
                           "Sarasa Mono Slab TC"
                           "Noto Sans CJK TC"
                           "Source Han Sans TC"
                           "Microsoft YaHei"))
          (symbol
           ,(zy-pick-font! "Noto Sans Symbols"
                           "Wingdings")))
        "Preset value of `zy$fontlist-default'")

      (defcustom zy$fontlist-default zy-fontlist-default-preset
        "Fontlist used on most occasions."
        :type 'sexp)

      (defvar zy-fontlist-default-without-size
        (zy-copy-fontlist-without-size zy$fontlist-default)
        "Fontlist used on most occasions, without size information.")

      (defconst zy-fontlist-varpitch-preset
        `(,(zy-pick-main-font! ("IBM Plex Serif" 18)
                               ("Times New Roman" 18)
                               ("serif" 18))
          ((han cjk-misc bopomofo kana)
           ,(zy-pick-font! "GenYoMin TW"
                           "Source Han Serif TC"
                           "STSong")))
        "Preset value of `zy$fontlist-varpitch'")

      (defcustom zy$fontlist-varpitch zy-fontlist-varpitch-preset
        "Fontlist used for 'variable-pitch' face."
        :type 'sexp)

      (defconst zy-fontlist-title-preset
        `(,(zy-pick-main-font! ("Roboto Slab")
                               ("Noto Sans")
                               ("Calibri")
                               ("sans"))
          ((han cjk-misc bopomofo kana)
           ,(zy-pick-font! "GenYoGothic TW"
                           "Sarasa Mono Slab TC"
                           "Source Han Sans TC"
                           "Noto Sans CJK TC"
                           "Microsoft YaHei")))
        "Preset value of `zy$fontlist-title'")

      (defcustom zy$fontlist-title zy-fontlist-title-preset
        "Fontlist used for titles."
        :type 'sexp)

      (defcustom zy$font-size-adjust 0
        "How many pixels should font size be adjusted."
        :type 'integer)

      (dolist (fontlist `(,zy$fontlist-default
                          ,zy$fontlist-varpitch
                          ,zy$fontlist-title))
        (zy-fontlist-adjust-size fontlist zy$font-size-adjust))
      (zy-fontlist-apply zy$fontlist-default 'default)
      (zy-fontlist-apply zy$fontlist-varpitch 'variable-pitch)))
#+end_src

*** 中西文字體等寬判斷

根據以下內容判斷等寬性：

#+begin_src text
等寬 等寬 等寬 等寬 等寬 mono mono mono mono mono
mono mono mono mono mono 等寬 等寬 等寬 等寬 等寬
#+end_src

** Frame Size

*** Frame Size Definition

#+begin_src emacs-lisp
  (defcustom zy$frame-width-standard 100
    "Standard frame width for new frames."
    :type 'integer)
  (defcustom zy$frame-height-standard 40
    "Standard frame height for new frames."
    :type 'integer)
  (defcustom zy$frame-width-darkroom 120
    "Standard frame width for Darkroom mode."
    :type 'integer)
  (defcustom zy$frame-height-darkroom 40
    "Standard frame height for Darkroom mode."
    :type 'integer)
#+end_src

*** Resize New Frames

#+begin_src emacs-lisp
  (defun zy/resize-frame (&optional frame no-rem)
    "Resize FRAME to standard size.

  If NO-REM is nil or omitted, remember the frame size before
  resize in the 'width-rem' and 'height-rem' frame parameters."
    (interactive)
    (when (display-graphic-p)
      (let* ((width-standard (if (and (boundp 'darkroom-mode)
                                      darkroom-mode)
                                 zy$frame-width-darkroom
                               zy$frame-width-standard))
             (height-standard (if (and (boundp 'darkroom-mode)
                                      darkroom-mode)
                                 zy$frame-height-darkroom
                               zy$frame-height-standard))
             (is-standard (and
                           (= (frame-width) width-standard)
                           (= (frame-height) height-standard)))
             (width-rem (frame-parameter frame 'width-rem))
             (height-rem (frame-parameter frame 'height-rem)))
        (unless (or no-rem is-standard)
          (modify-frame-parameters frame
                                   `((width-rem . ,(frame-width))
                                     (height-rem . ,(frame-height)))))
        (if (and is-standard width-rem height-rem)
            (set-frame-size frame width-rem height-rem)
          (set-frame-size frame width-standard height-standard)))))

  (add-to-list 'after-make-frame-functions
               #'zy/resize-frame)
  (add-hook-lambda! 'emacs-startup-hook
    (zy/resize-frame nil 'no-rem))
#+end_src

** Distraction-Free Mode

#+begin_src emacs-lisp
  (straight-use-package 'darkroom)
  (setq darkroom-margins 0.1
        darkroom-text-scale-increase 1)
  (general-define-key
   :keymaps 'zy-leader-manage-map
   "d" #'darkroom-mode)
  (add-hook-lambda! 'darkroom-mode-hook
    (let ((inhibit-message t))
      (delete-other-windows))
    (hl-line-mode 'toggle))

  (with-eval-after-load 'darkroom
    (defun zy-darkroom-switch-size (&optional frame)
      "Switch FRAME size for `darkroom-mode'.

  All actions below assumes that there is only one window in
  FRAME, and GUI is active. Otherwise, do nothing.

  If 'darkroom-mode' is enabled, and current frame size is
  `zy$frame-size-standard', resize to `zy$frame-size-darkroom'.

  If 'darkroom-mode' is disabled, and current frame size is
  `zy$frame-size-darkroom', resize to `zy$frame-size-standard'.

  Otherwise, do nothing."
      (when (and (display-graphic-p)
                 (equal (progn
                          (when frame (select-frame frame))
                          (count-windows))
                        1))
        (let* ((width-cur (frame-parameter frame 'width))
               (height-cur (frame-parameter frame 'height))
               (s2d (and (boundp 'darkroom-mode)
                         darkroom-mode
                         (equal width-cur zy$frame-width-standard)
                         (equal height-cur zy$frame-height-standard)))
               (d2s (and (nand! (boundp 'darkroom-mode)
                                darkroom-mode)
                         (equal width-cur zy$frame-width-darkroom)
                         (equal height-cur zy$frame-height-darkroom))))
          (cond
           (s2d (set-frame-size frame
                                zy$frame-width-darkroom
                                zy$frame-height-darkroom))
           (d2s (set-frame-size frame
                                zy$frame-width-standard
                                zy$frame-height-standard))
           (t nil)))))

    (add-hook 'darkroom-mode-hook #'zy-darkroom-switch-size)
    (add-to-list 'window-buffer-change-functions
                 #'zy-darkroom-switch-size))
#+end_src

* Lingual | 語言相關
** Encoding

Make everything UTF-8.

#+begin_src emacs-lisp
  (prefer-coding-system 'utf-8)
  (set-language-environment "UTF-8")
#+end_src

** Rime Input Method

#+begin_src emacs-lisp
  (straight-use-package 'rime)
  (setq rime-user-data-dir (expand-file-name "rime" user-emacs-directory)
        default-input-method "rime"
        rime-show-candidate 'posframe)

  ;; Make the cursor orange when IM is active
  (defcustom zy$im-cursor-color "#f68a06"
    "Default cursor color if an input method is active."
    :type 'color)
  (defvar zy--default-cursor-color (frame-parameter nil 'cursor-color)
    "Default text cursor color.")
  (defun zy--change-cursor-color-on-im ()
    "Set cursor color depending IM state."
    (set-cursor-color (if current-input-method
                          zy$im-cursor-color
                        zy--default-cursor-color)))
  (add-hook 'post-command-hook 'zy--change-cursor-color-on-im)
#+end_src

* Major Modes | 各主模式設置

** Emacs Lisp

#+begin_src emacs-lisp
  (add-hook-lambda! 'emacs-lisp-mode-hook
    (setq-local fill-column 70))
#+end_src

** Org

*** Basic Org

#+begin_src emacs-lisp
  (straight-use-package '(org :type git :host github
                              :repo "bzg/org-mode"))
  (setq org-attach-id-dir "_org-att"
        org-src-window-setup 'current-window
        org-tags-column 0)
  (add-hook-lambda! 'org-mode-hook
    (display-line-numbers-mode -1)
    (org-indent-mode +1)
    (variable-pitch-mode +1)
    (visual-line-mode +1))

  (with-eval-after-load 'org
    (defun zy--setup-org-faces ()
      "Setup custom faces for org-mode."
      (when (display-graphic-p)
        ;; Headline faces.
        (zy-fontlist-apply! zy$fontlist-title
                            'org-level-1
                            'org-level-2
                            'org-level-3
                            'org-level-4
                            'org-level-5
                            'org-level-6
                            'org-level-7
                            'org-level-8)
        (dolist (level (number-sequence 1 8))
          (set-face-attribute
           (intern (format "org-level-%d" level))
           nil
           :height
           (string-to-number (format "1.%d" (- 4 level)))
           :weight
           (if (< level 3)
               'bold
             'semi-bold)))
        ;; Other faces.
        (zy-fontlist-apply! zy-fontlist-default-without-size
                            'org-block
                            'org-code
                            'org-todo
                            'org-verbatim)
        (set-face-attribute 'org-todo nil :weight 'bold)))
    (zy--setup-org-faces)
    (add-hook 'after-enable-theme-hook #'zy--setup-org-faces))
#+end_src

*** GTD System

Enable the GTD system when ~zy$gtd-path~ is valid.

#+begin_src emacs-lisp
  (defcustom zy$use-gtd-p t
    "Should ZyEmacs use the built-in GTD system.

  If `zy$gtd-path' does not exist as a directory, this variable
  will be automatically set to nil."
    :type 'boolean)

  (defcustom zy$gtd-path (if zy$use-zybox-p
                             (expand-file-name "org/org-gtd"
                                               zy$zybox-path)
                           org-directory)
    "Where the GTD files are stored."
    :type 'directory)

  (unless (file-directory-p zy$gtd-path)
    (setq zy$use-gtd-p nil))

  (when zy$use-gtd-p
    (defvar zy-gtd-inbox-file
      (expand-file-name "inbox.org" zy$gtd-path)
      "The path of \"inbox.org\" of the GTD system.")
    (defvar zy-gtd-gtd-file
      (expand-file-name "gtd.org" zy$gtd-path)
      "The path of \"gtd.org\" of the GTD system.")
    (defvar zy-gtd-someday-file
      (expand-file-name "someday.org" zy$gtd-path)
      "The path of \"someday.org\" of the GTD system.")
    (defvar zy-gtd-files
      `(,zy-gtd-inbox-file ,zy-gtd-gtd-file ,zy-gtd-someday-file)
      "List of all files of the GTD system.")

    ;; Create empty GTD file if not exists.
    (dolist (file zy-gtd-files)
      (unless (file-exists-p file)
        (write-region "" nil file)))

    (setq
     org-log-done 'time
     org-log-refile 'time
     org-agenda-files `(,zy-gtd-inbox-file
                        ,zy-gtd-gtd-file
                        ,zy-gtd-someday-file)
     org-capture-templates `(("i" "inbox" entry
                              (file+headline ,zy-gtd-inbox-file "inbox")
                              "* TODO [#B] %u %i%?"
                              :empty-lines 1)
                             ("s" "someday" entry
                              (file+headline ,zy-gtd-someday-file "someday")
                              "* TODO [#C] %u %i%?"
                              :empty-lines 1)
                             ("t" "GTD" entry
                              (file+olp+datetree ,zy-gtd-gtd-file)
                              "* TODO [#B] %u %i%?"
                              :empty-lines 1))
     org-refile-targets `((,zy-gtd-gtd-file :maxlevel . 3)
                          (,zy-gtd-someday-file :level . 1))
     org-todo-keywords '((sequence "TODO(t)"
                                   "IN PROCESS(i)"
                                   "POSTPONED(p)"
                                   "|"
                                   "DONE(d)")
                         (sequence "|"
                                   "CANCELED(c)")
                         (sequence "BUSY(b)"
                                   "NOT BUSY(n)"
                                   "|"))
     org-todo-keyword-faces '(("TODO" .
                               (:inherit org-todo :foreground "#B71C1C"))
                              ("IN PROCESS" .
                               (:inherit org-todo :foreground "#8BC34A"))
                              ("POSTPONED" .
                               (:inherit org-todo :foreground "#F57C00"))
                              ("DONE" .
                               (:inherit org-todo :foreground "#33691E"))
                              ("CANCELED" .
                               (:inherit org-todo :foreground "#757575"))
                              ("BUSY" .
                               (:inherit org-todo :foreground "#B916FF"))
                              ("NOT BUSY" .
                               (:inherit org-todo :foreground "#DE90FF"))))

    (general-define-key
     :keymaps 'zy-leader-map
     "a" 'org-agenda
     "c" 'org-capture))
#+end_src

*** Org-Appear

#+begin_src emacs-lisp
  (straight-use-package 'org-appear)
  (add-hook 'org-mode-hook 'org-appear-mode)
  (setq-default org-hide-emphasis-markers t)
#+end_src

*** Org-Superstar

#+begin_src emacs-lisp
  (straight-use-package 'org-superstar)
  (add-hook 'org-mode-hook 'org-superstar-mode)
  (setq org-superstar-headline-bullets-list '(#x25c9
                                              #x25cb
                                              #x25c8
                                              #x25c7
                                              #x2666)
        org-superstar-cycle-headline-bullets nil
        org-hide-leading-stars nil
        org-superstar-leading-bullet #x200b
        org-indent-mode-turns-on-hiding-stars nil
        org-superstar-item-bullet-alist '((42 . #x2605)
                                          (43 . #x2666)
                                          (45 . #x27a4)))
  (with-eval-after-load 'org-superstar
    (zy-fontlist-apply! zy-fontlist-default-without-size
                        'org-superstar-header-bullet
                        'org-superstar-item))
#+end_src

*** Org-Journal

#+begin_src emacs-lisp
  (straight-use-package 'org-journal)
  (general-define-key
   :keymaps 'zy-leader-map
   "g" 'calendar
   "j" 'org-journal-new-entry)
  (setq org-journal-extend-today-until 3
        org-journal-file-format "%F.org"
        org-journal-date-format "%F %a W%V\n"
        org-journal-date-prefix "#+title: "
        org-journal-time-format "%R "
        org-journal-time-format-post-midnight "%R (midnight) "
        org-journal-time-prefix "\n* "
        org-journal-file-header "")
  (when zy$use-zybox-p
    (setq org-journal-dir
          (expand-file-name "org/org-journal" zy$zybox-path)))
#+end_src

*** Org-Roam

**** Setup

Load org-roam when ~org-roam-directory~ is valid.

#+begin_src emacs-lisp
  (when zy$zybox-path
    (customize-set-value 'org-roam-directory
                         (expand-file-name
                          "org/org-roam"
                          zy$zybox-path)))

  (defvar zy$use-org-roam-p t
    "Should ZyEmacs use org-roam.

  If `org-roam-directory' does not exist as a directory, this
  variable will be automatically set to nil.")

  (unless (and (boundp 'org-roam-directory)
               (file-directory-p org-roam-directory))
    (setq zy$use-org-roam-p nil))

  (when zy$use-org-roam-p
    (straight-use-package 'org-roam))
#+end_src

** Markdown

#+begin_src emacs-lisp
  (straight-use-package 'markdown-mode)
  (add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
  (add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
  (add-to-list 'auto-mode-alist '("README\\.md\\'" . gfm-mode))

  (with-eval-after-load 'markdown-mode
    (straight-use-package 'markdown-toc))
#+end_src

** Verilog

#+begin_src emacs-lisp
  (straight-use-package 'verilog-mode)
#+end_src
